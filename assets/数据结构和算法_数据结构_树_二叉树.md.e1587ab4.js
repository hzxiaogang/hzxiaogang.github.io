import{_ as s,o as a,c as n,V as l}from"./chunks/framework.364d6ed5.js";const o="/tree4.png",e="/tree5.png",p="/tree6.png",_=JSON.parse('{"title":"二叉树","description":"","frontmatter":{"title":"二叉树","date":"2022-06-22T18:23:24.000Z","permalink":"/pages/c9a4a3/","categories":["数据结构和算法","数据结构","树"],"tags":[null]},"headers":[],"relativePath":"数据结构和算法/数据结构/树/二叉树.md","filePath":"数据结构和算法/数据结构/树/二叉树.md","lastUpdated":1685624511000}'),t={name:"数据结构和算法/数据结构/树/二叉树.md"},r=l('<h2 id="_1-定义" tabindex="-1">1. 定义 <a class="header-anchor" href="#_1-定义" aria-label="Permalink to &quot;1. 定义&quot;">​</a></h2><p>二叉树，顾名思义，最多仅有两个子节点的树（最多能分两个叉的树）。 如下图： <img src="'+o+'"></p><h2 id="_2-二叉树分类" tabindex="-1">2. 二叉树分类 <a class="header-anchor" href="#_2-二叉树分类" aria-label="Permalink to &quot;2. 二叉树分类&quot;">​</a></h2><h3 id="_2-1-平衡二叉树" tabindex="-1">2.1 平衡二叉树 <a class="header-anchor" href="#_2-1-平衡二叉树" aria-label="Permalink to &quot;2.1 平衡二叉树&quot;">​</a></h3><p><strong>⼆叉树</strong>中，每⼀个节点的左右 <strong>⼦树</strong> 的 <strong>⾼度</strong>相差不能⼤于 <code>1</code>，称为平衡⼆叉树。 <img src="'+e+`"></p><h3 id="_2-2-满二叉树" tabindex="-1">2.2 满⼆叉树 <a class="header-anchor" href="#_2-2-满二叉树" aria-label="Permalink to &quot;2.2 满⼆叉树&quot;">​</a></h3><p>除了叶子结点外每⼀个结点都有左右⼦叶且叶⼦结点都处在最底层的⼆叉树</p><h3 id="_2-3-完全二叉树" tabindex="-1">2.3 完全⼆叉树 <a class="header-anchor" href="#_2-3-完全二叉树" aria-label="Permalink to &quot;2.3 完全⼆叉树&quot;">​</a></h3><p>深度为<code>h</code>，除第 <code>h</code> 层外，其它各层 (<code>1～h-1</code>) 的结点数都达到最⼤个数，第<code>h</code> 层所有 的结点都连续集中在最左边。（可以理解为 <code>1~h-1</code> 层是一个<strong>满二叉树</strong>，<code>h</code> 层所有叶子节点连续左对齐）</p><h2 id="_3-代码表示一个二叉树" tabindex="-1">3. 代码表示一个二叉树 <a class="header-anchor" href="#_3-代码表示一个二叉树" aria-label="Permalink to &quot;3. 代码表示一个二叉树&quot;">​</a></h2><h3 id="_3-1-链式存储法" tabindex="-1">3.1 链式存储法 <a class="header-anchor" href="#_3-1-链式存储法" aria-label="Permalink to &quot;3.1 链式存储法&quot;">​</a></h3><p>二叉树的存储很简单，在二叉树中，我们看到每个<strong>节点</strong>包含<strong>三个部分</strong></p><ul><li><ol><li>当前节点的 val</li></ol></li><li><ol start="2"><li>左子节点 left</li></ol></li><li><ol start="3"><li>右子节点 right</li></ol></li></ul><p>所有我们可以将每个节点定义为：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Node</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">val</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 保存当前节点 key 值</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">val</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 指向左子节点</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">left</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 指向右子节点</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">right</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>一棵二叉树可以由根节点通过左右指针连接起来形成一个树</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">BinaryTree</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Node</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">val</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">val</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">left</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">right</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">root</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_3-2-数组存储法-适用于完全二叉树" tabindex="-1">3.2 数组存储法（适用于完全二叉树） <a class="header-anchor" href="#_3-2-数组存储法-适用于完全二叉树" aria-label="Permalink to &quot;3.2 数组存储法（适用于完全二叉树）&quot;">​</a></h3><p>下图就是一棵完全二叉树 <img src="`+p+'"></p><p>如果我们把根节点存放在位置 <code>i=1</code> 的位置，则它的左⼦节点位置为 <code>2i = 2</code> ，右⼦节点位置为 <code>2i+1 = 3</code> 。</p><p>如果我们选取 <code>B</code> 节点 <code>i=2</code>，则它⽗节点为 <code>i/2 = 1</code> ，左⼦节点 <code>2i=4</code> ，右⼦节点 <code>2i+1=5</code> 。 以此类推，我们发现所有的节点都满⾜这三种关系：</p><ul><li><ol><li>位置为<code>i</code>的节点，它的父节点位置为<code>i/2</code></li></ol></li><li><ol start="2"><li>它的左子节点的位置为<code>2i</code></li></ol></li><li><ol start="3"><li>它的右子节点位置为<code>2i+1</code></li></ol></li></ul><p>因此，如果我们把完全二叉树存储在数组里（从下标为 1 开始存储），我们完全可以通过下标找到任意节点的父子节点。从而完整的构建出这个完全二叉树。这就是数组存储法。</p><p>数组存储法相对于链式存储法，不需要为每个节点创建它的左右指针，更为节省内存</p>',24),c=[r];function i(F,d,y,D,h,u){return a(),n("div",null,c)}const m=s(t,[["render",i]]);export{_ as __pageData,m as default};
