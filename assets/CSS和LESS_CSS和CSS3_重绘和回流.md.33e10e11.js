import{_ as s,o as a,c as l,V as n}from"./chunks/framework.364d6ed5.js";const e="/css.png",F=JSON.parse('{"title":"重绘和回流","description":"","frontmatter":{"title":"重绘和回流","date":"2021-12-04T13:00:37.000Z","permalink":"/pages/ceed62/","categories":["CSS和LESS","CSS和CSS3"],"tags":[null]},"headers":[],"relativePath":"CSS和LESS/CSS和CSS3/重绘和回流.md","filePath":"CSS和LESS/CSS和CSS3/重绘和回流.md","lastUpdated":1685623283000}'),o={name:"CSS和LESS/CSS和CSS3/重绘和回流.md"},p=n('<h2 id="_1-浏览器的渲染过程" tabindex="-1">1. 浏览器的渲染过程 <a class="header-anchor" href="#_1-浏览器的渲染过程" aria-label="Permalink to &quot;1. 浏览器的渲染过程&quot;">​</a></h2><p>下面这张图展示了浏览器的渲染过程：</p><img src="'+e+`"><p>从这张图我们可以看到，浏览器的渲染过程如下：</p><ol><li><strong>解析HTML</strong>，生成DOM树</li><li><strong>解析CSS</strong>，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树（Render Tree）</li><li>Reflow(回流)：根据生成的渲染树，进行回流（Reflow），得到节点的几何信息（位置，大小）</li><li>Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display ：将像素发送给GPU，展示在页面上。</li></ol><h2 id="_2-回流" tabindex="-1">2. 回流 <a class="header-anchor" href="#_2-回流" aria-label="Permalink to &quot;2. 回流&quot;">​</a></h2><h3 id="_2-1-简介" tabindex="-1">2.1 简介 <a class="header-anchor" href="#_2-1-简介" aria-label="Permalink to &quot;2.1 简介&quot;">​</a></h3><p>通过渲染树将可见DOM节点以及对应的样式结合起来，可是我们还需要计算它们在设备视口（viewport）内的确切位置和大小，这个计算的阶段就是回流。例如将一个div的宽度设置为50%，浏览器会在回流阶段计算出这个50%在设备视口的具体值。</p><h3 id="_2-1-触发回流" tabindex="-1">2.1 触发回流 <a class="header-anchor" href="#_2-1-触发回流" aria-label="Permalink to &quot;2.1 触发回流&quot;">​</a></h3><p>回流这一阶段主要是计算节点的位置和信息。那么当页面<strong>页面布局</strong>和<strong>几何信息</strong>发生变化的时候，就需要回流。 比如以下情况：</p><ol><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（margin，border，padding，width，height等）</li><li>内容发生变化，比如文本变化或图片被另外一个不同尺寸的图片所代替</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸发生变化（因为回流是根据浏览器的视口来计算元素的大小和位置的）</li></ol><h2 id="_3-重绘" tabindex="-1">3. 重绘 <a class="header-anchor" href="#_3-重绘" aria-label="Permalink to &quot;3. 重绘&quot;">​</a></h2><p>回流一定会触发重绘，而重绘不一定会回流</p><h3 id="_3-1-简介" tabindex="-1">3.1 简介 <a class="header-anchor" href="#_3-1-简介" aria-label="Permalink to &quot;3.1 简介&quot;">​</a></h3><p>通过构造渲染树和回流阶段，浏览器知道了那些节点是可见的，以及可见节点的样式和具体的几何信息（位置，大小）。将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘。</p><h3 id="_3-2-触发重绘" tabindex="-1">3.2 触发重绘 <a class="header-anchor" href="#_3-2-触发重绘" aria-label="Permalink to &quot;3.2 触发重绘&quot;">​</a></h3><p>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫触发重绘</p><h2 id="_4-浏览器的优化机制" tabindex="-1">4. 浏览器的优化机制 <a class="header-anchor" href="#_4-浏览器的优化机制" aria-label="Permalink to &quot;4. 浏览器的优化机制&quot;">​</a></h2><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：</p><ol><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>getComputedStyle()</li><li>getBoundingClientRect</li></ol><p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列</strong>。如果要使用它们，最好将值<strong>缓存</strong>起来。</p><h2 id="_5-减少回流和重绘" tabindex="-1">5. 减少回流和重绘 <a class="header-anchor" href="#_5-减少回流和重绘" aria-label="Permalink to &quot;5. 减少回流和重绘&quot;">​</a></h2><h3 id="_5-1最小化重绘和回流" tabindex="-1">5.1最小化重绘和回流 <a class="header-anchor" href="#_5-1最小化重绘和回流" aria-label="Permalink to &quot;5.1最小化重绘和回流&quot;">​</a></h3><p>由于重绘和回流可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> el </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">padding </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">5px</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">borderLeft </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">1px</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">borderRight </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">2px</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次回流。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次回流。 因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：</p><h4 id="使用csstext" tabindex="-1">使用cssText <a class="header-anchor" href="#使用csstext" aria-label="Permalink to &quot;使用cssText&quot;">​</a></h4><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> el </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">style</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">cssText </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">border-left: 1px; border-right: 2px; padding: 5px;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="修改css的class" tabindex="-1">修改CSS的class <a class="header-anchor" href="#修改css的class" aria-label="Permalink to &quot;修改CSS的class&quot;">​</a></h4><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> el </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">test</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">className </span><span style="color:#89DDFF;">+=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;"> active</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_5-2-批量修改dom" tabindex="-1">5.2 批量修改DOM <a class="header-anchor" href="#_5-2-批量修改dom" aria-label="Permalink to &quot;5.2 批量修改DOM&quot;">​</a></h3><p>当我们需要对DOM进行一系列修改的时候，可以通过以下步骤减少回流重绘次数：</p><ol><li>使元素脱离文档流</li><li>对其进行多次修改</li><li>将元素带回到文档中</li></ol><p>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流，因为它已经不在渲染树了。有三种方式可以让DOM脱离文档流：</p><ol><li>隐藏元素，应用修改，重新显示</li><li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。</li><li>将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</li></ol><h3 id="_5-3-对于复杂动画效果-使用绝对定位让其脱离文档流" tabindex="-1">5.3 对于复杂动画效果,使用绝对定位让其脱离文档流 <a class="header-anchor" href="#_5-3-对于复杂动画效果-使用绝对定位让其脱离文档流" aria-label="Permalink to &quot;5.3 对于复杂动画效果,使用绝对定位让其脱离文档流&quot;">​</a></h3><p>对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。</p><h3 id="_5-4-css3硬件加速-gpu加速" tabindex="-1">5.4 css3硬件加速（GPU加速） <a class="header-anchor" href="#_5-4-css3硬件加速-gpu加速" aria-label="Permalink to &quot;5.4 css3硬件加速（GPU加速）&quot;">​</a></h3><p>比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能</p>`,39),t=[p];function r(c,i,D,d,y,h){return a(),l("div",null,t)}const A=s(o,[["render",r]]);export{F as __pageData,A as default};
