import{_ as e,o as i,c as t,V as r}from"./chunks/framework.364d6ed5.js";const l="/tree14.png",a="/tree15.png",g=JSON.parse('{"title":"Trie树","description":"","frontmatter":{"title":"Trie树","date":"2022-06-29T16:40:34.000Z","permalink":"/pages/33d317/","categories":["数据结构和算法","数据结构","树"],"tags":[null]},"headers":[],"relativePath":"数据结构和算法/数据结构/树/Trie树.md","filePath":"数据结构和算法/数据结构/树/Trie树.md","lastUpdated":1685624511000}'),o={name:"数据结构和算法/数据结构/树/Trie树.md"},s=r('<h2 id="_1-什么是-trie-树" tabindex="-1">1. 什么是 Trie 树 <a class="header-anchor" href="#_1-什么是-trie-树" aria-label="Permalink to &quot;1. 什么是 Trie 树&quot;">​</a></h2><p>Trie 树，也称为<strong>字典树</strong>或<strong>前缀树</strong>，顾名思义，它是⽤来处理<strong>字符串匹配问题</strong>的数据结构，以及⽤来解 决集合中查找固定前缀字符串的数据结构。</p><p>Trie 树的本质是利⽤字符串的公共前缀，将᯿复的前缀合并在⼀起，其中根节点不包含任何信息，每 个节点表示⼀个字符串中的字符，从根节点到叶节点的路径，表示⼀个字符串。</p><p>在字符串匹配的时候，我们只要按照树的结构从上到下匹配即可。</p><h2 id="_2-trie-树特点" tabindex="-1">2. trie 树特点 <a class="header-anchor" href="#_2-trie-树特点" aria-label="Permalink to &quot;2. trie 树特点&quot;">​</a></h2><ul><li><ol><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li></ol></li><li><ol start="2"><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li></ol></li><li><ol start="3"><li>每个节点的所有子节点包含的字符都不相同。</li></ol></li></ul><h2 id="_3-应用场景" tabindex="-1">3. 应用场景 <a class="header-anchor" href="#_3-应用场景" aria-label="Permalink to &quot;3. 应用场景&quot;">​</a></h2><ul><li><ol><li>搜索引擎的 suggest 功能</li></ol></li><li><ol start="2"><li>词频统计</li></ol></li><li><ol start="3"><li>IDE 里面自动补全功能</li></ol></li><li><ol start="4"><li>各种通讯录的自动补全功能</li></ol></li></ul><h2 id="_4-trie-树的应用-字符串匹配-搜索引擎的自动联想" tabindex="-1">4. Trie 树的应用 ： 字符串匹配（搜索引擎的自动联想） <a class="header-anchor" href="#_4-trie-树的应用-字符串匹配-搜索引擎的自动联想" aria-label="Permalink to &quot;4. Trie 树的应用 ： 字符串匹配（搜索引擎的自动联想）&quot;">​</a></h2><p>在搜索引擎中输⼊关键字，搜索引擎都会弹出下拉框，显示各种关键字提示，例如必应： <img src="'+l+'"></p><p>必应是如何处理这⼀过程的呢？</p><p>或者，假设我们有 n 个单词的数据集，任意输⼊⼀串字符，如何在数据集中快速匹配出具有输⼊字符 前缀的单词？</p><p>这样类似的问题还有很多，在⽇常开发中，遇到类似的问题，我们应该如何去处理？选择怎样的数据 结构与算法？尤其是遇到⼤规模数据时，如何更⾼效的处理？</p><p>最简单的⽅法就是暴⼒，将数据集中的每个字符串，逐个字符的匹配输⼊字符，所有字符都匹配上则 前缀匹配成功。这种⽅式也是我们开发当中最常⽤，最简单的⽅式，时间复杂度为 O(m*n) ，其中 m 为输⼊字符串⻓度， n 为数据集规模。</p><p>这个时间复杂度是很⾼的，当 n 很⼤时，暴⼒法性能就会很差，此时必须᯿新寻找合适的算法。</p><p>我们知道在树上查找、插⼊都⽐较⽅便，⼀般时间复杂度只与树的⾼度相关，我们可以通过树结构来 处理，也就是我们要说的 Trie 树。其实，引擎搜索关键字提示底层也是通过 Trie 树实现的。</p><p>假设有 5 个字符串，它们分别是：Code，Cook，Five，File，Fat。现在需要在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 5 个字符串依次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？</p><p>如果将这 5 个字符串组织成下图的结构，从肉眼上扫描过去感官上是不是比查找起来会更加迅速。</p><img src="'+a+'">',19),n=[s];function p(_,c,d,h,T,m){return i(),t("div",null,n)}const f=e(o,[["render",p]]);export{g as __pageData,f as default};
