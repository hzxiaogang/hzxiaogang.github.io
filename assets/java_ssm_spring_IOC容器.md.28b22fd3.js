import{_ as e,o as t,c as o,V as c}from"./chunks/framework.364d6ed5.js";const g=JSON.parse('{"title":"IOC容器","description":"","frontmatter":{"title":"IOC容器","date":"2022-10-20T21:49:34.000Z","permalink":"/pages/f3c0aa/","categories":["java","ssm","spring"],"tags":[null]},"headers":[],"relativePath":"java/ssm/spring/IOC容器.md","filePath":"java/ssm/spring/IOC容器.md","lastUpdated":1705544536000}'),a={name:"java/ssm/spring/IOC容器.md"},d=c('<h1 id="ioc容器" tabindex="-1">IOC容器 <a class="header-anchor" href="#ioc容器" aria-label="Permalink to &quot;IOC容器&quot;">​</a></h1><h2 id="_1-ioc-容器思想" tabindex="-1">1. IOC 容器思想 <a class="header-anchor" href="#_1-ioc-容器思想" aria-label="Permalink to &quot;1. IOC 容器思想&quot;">​</a></h2><p><code>IOC</code>：<code>Inversion of Control</code>，翻译过来是反转控制。</p><h3 id="_1-di" tabindex="-1">1. DI <a class="header-anchor" href="#_1-di" aria-label="Permalink to &quot;1. DI&quot;">​</a></h3><p><code>DI</code>：<code>Dependency Injection</code>，翻译过来是依赖注入。</p><p><code>DI</code> 是 <code>IOC</code> 的另一种表述方式：即组件以一些预先定义好的方式（例如：<code>setter</code>方法）接受来自于容器 的资源注入。相对于<code>IOC</code> 而言，这种表述更直接。</p><p>所以结论是：<code>IOC</code>就是一种反转控制的思想， 而 <code>DI</code> 是对<code>IOC</code> 的一种具体实现。</p><h2 id="_2-ioc-容器在-spring-中的实现" tabindex="-1">2. IOC 容器在 Spring 中的实现 <a class="header-anchor" href="#_2-ioc-容器在-spring-中的实现" aria-label="Permalink to &quot;2. IOC 容器在 Spring 中的实现&quot;">​</a></h2><p><code>Spring</code>的<code>IOC</code>容器就是<code>IOC</code>思想的一个落地的产品实现。<code>IOC</code>容器中管理的组件也叫做<code>bean</code>。在创建<code>bean</code>之前，首先需要创建<code>IOC</code>容器。<code>Spring</code>提供了<code>IOC</code>容器的两种实现方式：</p><h3 id="_1-beanfactory" tabindex="-1">1. BeanFactory <a class="header-anchor" href="#_1-beanfactory" aria-label="Permalink to &quot;1. BeanFactory&quot;">​</a></h3><p>这是<code>IOC</code>容器的基本实现，是<code>Spring</code>内部使用的接口。面向<code>Spring</code>本身，不提供给开发人员使用</p><h3 id="_2-applicationcontext" tabindex="-1">2. ApplicationContext <a class="header-anchor" href="#_2-applicationcontext" aria-label="Permalink to &quot;2. ApplicationContext&quot;">​</a></h3><p><code>BeanFactory</code>的子接口，提供了更多高级特性。面向<code>Spring</code>的使用者，几乎所有场合都使用<code>ApplicationContext</code>而不是底层的<code>BeanFactory</code>。<code>ApplicationContext</code>有以下几个常用实现类：</p><table><thead><tr><th style="text-align:left;">类型名</th><th style="text-align:left;">简介</th></tr></thead><tbody><tr><td style="text-align:left;"><code>ClassPathXmlApplicationContext</code></td><td style="text-align:left;">通过读取类路径下的 <code>XML</code> 格式的配置文件创建 <code>IOC</code> 容器对象</td></tr><tr><td style="text-align:left;"><code>FileSystemXmlApplicationContext</code></td><td style="text-align:left;">通过文件系统路径读取 <code>XML</code> 格式的配置文件创建 <code>IOC</code> 容器对象</td></tr><tr><td style="text-align:left;"><code>ConfigurableApplicationContext</code></td><td style="text-align:left;"><code>ApplicationContext</code> 的<strong>子接口</strong>，包含一些扩展方法<code>refresh()</code> 和 <code>close()</code> ，让 <code>ApplicationContext</code> 具有<strong>启动</strong>、<strong>关闭</strong>和<strong>刷新</strong>上下文的能力。</td></tr><tr><td style="text-align:left;"><code>WebApplicationContext</code></td><td style="text-align:left;">专门为 <code>Web</code> 应用准备，基于<code>Web</code> 环境创建 <code>IOC</code> 容器对象，并将对象引入存入 <code>ServletContext</code>域中。</td></tr></tbody></table>',14),n=[d];function i(r,l,s,p,h,C){return t(),o("div",null,n)}const I=e(a,[["render",i]]);export{g as __pageData,I as default};
