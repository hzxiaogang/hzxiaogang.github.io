import{_ as l,o as t,c as i,V as a}from"./chunks/framework.364d6ed5.js";const e="/tree13.png",V=JSON.parse('{"title":"红⿊树","description":"","frontmatter":{"title":"红⿊树","date":"2022-06-29T16:53:05.000Z","permalink":"/pages/43a986/","categories":["数据结构和算法","数据结构","树"],"tags":[null]},"headers":[],"relativePath":"数据结构和算法/数据结构/树/红⿊树.md","filePath":"数据结构和算法/数据结构/树/红⿊树.md","lastUpdated":1685624511000}'),o={name:"数据结构和算法/数据结构/树/红⿊树.md"},r=a('<h2 id="_1-什么是红黑树" tabindex="-1">1. 什么是红黑树 <a class="header-anchor" href="#_1-什么是红黑树" aria-label="Permalink to &quot;1. 什么是红黑树&quot;">​</a></h2><p>红⿊树也是⼀种特殊的 <strong>⼆叉查找树</strong>。</p><p>红⿊树是⼀种⾃平衡（并不是绝对平衡）的⼆叉查找树，它除了满⾜二叉查找树的特点外，还满⾜以 下条件：</p><ul><li><ol><li>节点是红⾊或⿊⾊</li></ol></li><li><ol start="2"><li>根节点必须是⿊⾊节点</li></ol></li><li><ol start="3"><li>所有的叶⼦节点都必须是值为 NULL 的⿊节点</li></ol></li><li><ol start="4"><li>如果⼀个节点是红⾊的，则它两个⼦节点都是⿊⾊的</li></ol></li><li><ol start="5"><li>从任⼀节点到达它的每个叶⼦节点的所有的路径，都有相同数⽬的⿊⾊节点</li></ol></li></ul><img src="'+e+'"><p>这些条件保证红⿊树的⾃平衡，保证红⿊树从根节点到达每⼀个叶⼦节点的最⻓路径不会超过最 短路径的 2 倍。</p><p>⽽节点的路径⻓度决定着对节点的查询效率，这样我们确保了，最坏情况下的查找、插⼊、删除操作 的时间复杂度不超过 O(logn) ，并且有较⾼的插⼊和删除效率</p><h2 id="_2-红黑树-vs-平衡二叉树" tabindex="-1">2. 红⿊树 VS 平衡⼆叉树 <a class="header-anchor" href="#_2-红黑树-vs-平衡二叉树" aria-label="Permalink to &quot;2. 红⿊树 VS 平衡⼆叉树&quot;">​</a></h2><ul><li><ol><li>插⼊和删除操作，⼀般认为红⿊树的删除和插⼊会⽐ AVL 树更快。因为，红⿊树不像 AVL 树那 样严格的要求平衡因⼦⼩于等于 1，这就减少了为了达到平衡⽽进⾏的旋转操作次数，可以说是 牺牲严格平衡性来换取更快的插⼊和删除时间。</li></ol></li><li><ol start="2"><li>红⿊树不要求有不严格的平衡性控制，但是红⿊树的特点，使得任何不平衡都会在三次旋转之内 解决。⽽ AVL 树如果不平衡，并不会控制旋转操作次数，旋转直到平衡为⽌。</li></ol></li><li><ol start="3"><li>查找操作，AVL 树的效率更⾼。因为 AVL 树设计⽐红⿊树更加平衡，不会出现平衡因⼦超过 1 的 情况，减少了树的平均搜索⻓度。</li></ol></li></ul>',9),s=[r];function _(n,c,p,d,h,m){return t(),i("div",null,s)}const f=l(o,[["render",_]]);export{V as __pageData,f as default};
