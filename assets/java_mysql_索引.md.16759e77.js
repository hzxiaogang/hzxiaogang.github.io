import{_ as e,o as a,c as o,V as l}from"./chunks/framework.364d6ed5.js";const _=JSON.parse('{"title":"索引","description":"","frontmatter":{"title":"索引","date":"2022-09-20T23:13:20.000Z","permalink":"/pages/1bd96f/","categories":["java","mysql"],"tags":[null]},"headers":[],"relativePath":"java/mysql/索引.md","filePath":"java/mysql/索引.md","lastUpdated":1685806707000}'),n={name:"java/mysql/索引.md"},s=l(`<h1 id="索引" tabindex="-1">索引 <a class="header-anchor" href="#索引" aria-label="Permalink to &quot;索引&quot;">​</a></h1><p>说起提高数据库性能，索引是最方便的，不用<strong>加内存</strong>，不用改程序，不用调<code>sql</code>，查询速度就可能提高百倍千倍</p><h2 id="_1-举例说明索引的好处" tabindex="-1">1. 举例说明索引的好处 <a class="header-anchor" href="#_1-举例说明索引的好处" aria-label="Permalink to &quot;1. 举例说明索引的好处&quot;">​</a></h2><p>创建<code>emp</code>表有800万条数据。</p><h3 id="_1-1-在没有创建索引时-我们查询一条记录" tabindex="-1">1.1 在没有创建索引时，我们查询一条记录 <a class="header-anchor" href="#_1-1-在没有创建索引时-我们查询一条记录" aria-label="Permalink to &quot;1.1 在没有创建索引时，我们查询一条记录&quot;">​</a></h3><p>我们会发现，这条<code>sql</code>语句执行了近<code>5</code>秒</p><p><code>SELECT * FROM emp where empno = 123456</code></p><h3 id="_1-2-使用索引来优化查询速度" tabindex="-1">1.2 使用索引来优化查询速度 <a class="header-anchor" href="#_1-2-使用索引来优化查询速度" aria-label="Permalink to &quot;1.2 使用索引来优化查询速度&quot;">​</a></h3><p>在没有创建索引前，<code>emp.ibd</code> 文件的大小是 <code>524m</code></p><p><code>CREATE INDEX empno_index ON emp (empno)</code></p><ul><li>empno_index : 索引名字</li><li>ON emp (empno) ： 表示在<code>emp</code>表的<code>empno</code>列创建索引</li></ul><p>创建索引后，<code>emp.ibd</code> 文件大小是<code>655m</code>，说明<strong>索引本身也会占用空间</strong></p><h3 id="_1-3-创建索引后-体验查询速度" tabindex="-1">1.3 创建索引后，体验查询速度 <a class="header-anchor" href="#_1-3-创建索引后-体验查询速度" aria-label="Permalink to &quot;1.3 创建索引后，体验查询速度&quot;">​</a></h3><p>执行<code>sql</code>语句，我们会发现<code>0.003s</code>就执行完了，没添加索引前执行时间是近<code>5s</code>，查询速度极大提示。 <code>SELECT * FROM emp where empno = 123456</code></p><h3 id="_1-4-是不是建立一个索引就能解决所有问题" tabindex="-1">1.4 是不是建立一个索引就能解决所有问题？ <a class="header-anchor" href="#_1-4-是不是建立一个索引就能解决所有问题" aria-label="Permalink to &quot;1.4 是不是建立一个索引就能解决所有问题？&quot;">​</a></h3><p>上个案例中，我们在<code>empno</code>字段上加上了索引。但是<code>ename</code>并没有加。现在我们查询<code>ename</code>:</p><p><code>select * from emp where ename = &#39;tom&#39;</code></p><p>我们会发现，查询速度又变得很慢，<code>sql</code>执行时间又近<code>5s</code>。所以得出结论<strong>创建索引后，只对创建了索引的列有效</strong>。</p><p>现在我们再给<code>ename</code>字段加上索引。</p><p><code>CREATE INDEX ename_index ON emp (ename)</code></p><p>现在我们再执行查询语句:</p><p><code>select * from emp where ename = &#39;tom&#39;</code></p><p>我们会发现查询速度又变得很快，差不多<code>0.003s</code>。但是我们会发现<code>emp.ibd</code>文件大小变为<code>827m</code>。因因此每次新创建一个索引，对应的字段查询虽然变快，但是<code>emp.ibd</code>文件就会变得更大。此外，一旦查询条件字段变了，以前创建的索引就失效了。</p><h2 id="_2-索引的原理" tabindex="-1">2. 索引的原理 <a class="header-anchor" href="#_2-索引的原理" aria-label="Permalink to &quot;2. 索引的原理&quot;">​</a></h2><p>建立索引的二叉树，二叉树是建立索引的一种方式</p><h3 id="_2-1-没有索引为什么慢" tabindex="-1">2.1 没有索引为什么慢 <a class="header-anchor" href="#_2-1-没有索引为什么慢" aria-label="Permalink to &quot;2.1 没有索引为什么慢&quot;">​</a></h3><p>没有索引，查找会进行<strong>全表扫描</strong>，所以会很慢。</p><h3 id="_2-2-使用索引为什么会快" tabindex="-1">2.2 使用索引为什么会快 <a class="header-anchor" href="#_2-2-使用索引为什么会快" aria-label="Permalink to &quot;2.2 使用索引为什么会快&quot;">​</a></h3><p>会形成一个<strong>索引数据结构</strong>，比如<code>二叉数</code>，<code>B树</code>，<code>B+树</code>等，树形结构查找就会比较快。</p><h3 id="_2-3-索引的代价" tabindex="-1">2.3 索引的代价 <a class="header-anchor" href="#_2-3-索引的代价" aria-label="Permalink to &quot;2.3 索引的代价&quot;">​</a></h3><ul><li><ol><li>占用内存空间。</li></ol></li><li><ol start="2"><li>对<code>DML（update，delete，insert）</code>语句的效率影响。</li></ol></li></ul><p>因为删除或插入数据后，需要重构索引的数据结构（如二叉树数据结构），所以影响效率。虽然索引影响<code>DML</code>语句的效率。但是能极大提高<code>select</code>查询的效率。 在项目中使用<code>select</code>查询的次数远远高于<code>DML</code>操作，所以建立索引利大于弊。</p><h2 id="_3-索引类别" tabindex="-1">3. 索引类别 <a class="header-anchor" href="#_3-索引类别" aria-label="Permalink to &quot;3. 索引类别&quot;">​</a></h2><h3 id="_3-1-主键索引" tabindex="-1">3.1 主键索引 <a class="header-anchor" href="#_3-1-主键索引" aria-label="Permalink to &quot;3.1 主键索引&quot;">​</a></h3><p>主键自动的为主索引，类型为<code>primary key</code>。</p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">CREATE</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">TABLE</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">t1</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  id </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">primary key</span><span style="color:#A6ACCD;">,   </span><span style="color:#89DDFF;">//</span><span style="color:#A6ACCD;"> 主键，同时也是索引，称为主键索引</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F78C6C;">name</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">varchar</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">32</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-2-唯一索引-unique" tabindex="-1">3.2 唯一索引（UNIQUE） <a class="header-anchor" href="#_3-2-唯一索引-unique" aria-label="Permalink to &quot;3.2 唯一索引（UNIQUE）&quot;">​</a></h3><p>如果某列的值，是不会重复的，则优先考虑使用<code>unique</code>索引，否则使用<strong>普通索引</strong></p><div class="language-sql line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">CREATE</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">TABLE</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">t1</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  id </span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">unique</span><span style="color:#A6ACCD;">,  </span><span style="color:#89DDFF;">//</span><span style="color:#A6ACCD;"> id是唯一的，同时也是索引，称为unique索引</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F78C6C;">name</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">varchar</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">32</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-3-普通索引-index" tabindex="-1">3.3 普通索引（INDEX） <a class="header-anchor" href="#_3-3-普通索引-index" aria-label="Permalink to &quot;3.3 普通索引（INDEX）&quot;">​</a></h3><p>普通索引用的是最多的</p><h3 id="_3-4-全文索引-fulltext" tabindex="-1">3.4 全文索引（FULLTEXT） <a class="header-anchor" href="#_3-4-全文索引-fulltext" aria-label="Permalink to &quot;3.4 全文索引（FULLTEXT）&quot;">​</a></h3><p>适用用于<code>MyISAM</code>（<code>MyISAM</code>是<code>MySQL</code>的默认数据库引擎）。一般开发中，不使用<code>mysql</code>自带的全文索引，而是使用全文搜索框架<strong>全Sor和ElasticSearch（ES）</strong></p><h2 id="_4-创建索引" tabindex="-1">4. 创建索引 <a class="header-anchor" href="#_4-创建索引" aria-label="Permalink to &quot;4. 创建索引&quot;">​</a></h2><h3 id="_4-1-创建索引-index-unique" tabindex="-1">4.1 创建索引（INDEX,UNIQUE） <a class="header-anchor" href="#_4-1-创建索引-index-unique" aria-label="Permalink to &quot;4.1 创建索引（INDEX,UNIQUE）&quot;">​</a></h3><h4 id="_4-1-1-语法" tabindex="-1">4.1.1 语法 <a class="header-anchor" href="#_4-1-1-语法" aria-label="Permalink to &quot;4.1.1 语法&quot;">​</a></h4><p><code>CREATE [UNIQUE] INDEX index_name on table_name (col_name [(length)] [ASC|DESC] , ...)</code> 或 <code>alter table_name ADD INDEX [index_name] (index_col_name,...)</code></p><h4 id="_4-1-2-案例" tabindex="-1">4.1.2 案例 <a class="header-anchor" href="#_4-1-2-案例" aria-label="Permalink to &quot;4.1.2 案例&quot;">​</a></h4><ul><li><ol><li>创建唯一索引（unique）</li></ol></li></ul><p><code>CREATE UNIQUE INDEX id_index ON tb_emp (id)</code></p><ul><li><ol start="2"><li>创建普通索引</li></ol></li></ul><p><code>CREATE INDEX id_index ON tb_emp (id)</code></p><p>或</p><p><code>alter table tb_emp ADD INDEX id_index (id)</code></p><h3 id="_4-2-创建主键索引" tabindex="-1">4.2 创建主键索引 <a class="header-anchor" href="#_4-2-创建主键索引" aria-label="Permalink to &quot;4.2 创建主键索引&quot;">​</a></h3><h4 id="_4-2-1-语法" tabindex="-1">4.2.1 语法 <a class="header-anchor" href="#_4-2-1-语法" aria-label="Permalink to &quot;4.2.1 语法&quot;">​</a></h4><p><code>ALTER TABLE table_name ADD PRIMARY KEY (列名，...)</code></p><h4 id="_4-2-2-案例" tabindex="-1">4.2.2 案例 <a class="header-anchor" href="#_4-2-2-案例" aria-label="Permalink to &quot;4.2.2 案例&quot;">​</a></h4><p><code>ALTER TABLE tb_emp ADD PRIMARY KEY (id)</code></p><h2 id="_5-删除索引" tabindex="-1">5. 删除索引 <a class="header-anchor" href="#_5-删除索引" aria-label="Permalink to &quot;5. 删除索引&quot;">​</a></h2><h3 id="_5-1-删除索引-index-unique" tabindex="-1">5.1 删除索引（INDEX,UNIQUE） <a class="header-anchor" href="#_5-1-删除索引-index-unique" aria-label="Permalink to &quot;5.1 删除索引（INDEX,UNIQUE）&quot;">​</a></h3><h4 id="_5-1-1-语法" tabindex="-1">5.1.1 语法 <a class="header-anchor" href="#_5-1-1-语法" aria-label="Permalink to &quot;5.1.1 语法&quot;">​</a></h4><p><code>DROP INDEX index_name on table_name</code> 或 <code>alter table table_name drop index index_name</code></p><h4 id="_5-1-2-案例" tabindex="-1">5.1.2 案例 <a class="header-anchor" href="#_5-1-2-案例" aria-label="Permalink to &quot;5.1.2 案例&quot;">​</a></h4><p><code>DROP INDEX id_index ON tb_emp</code></p><h3 id="_5-2-删除主键索引" tabindex="-1">5.2 删除主键索引 <a class="header-anchor" href="#_5-2-删除主键索引" aria-label="Permalink to &quot;5.2 删除主键索引&quot;">​</a></h3><h4 id="_5-2-1-语法" tabindex="-1">5.2.1 语法 <a class="header-anchor" href="#_5-2-1-语法" aria-label="Permalink to &quot;5.2.1 语法&quot;">​</a></h4><p><code>alter table table_name drop primary key</code></p><h4 id="_5-2-2-案例" tabindex="-1">5.2.2 案例 <a class="header-anchor" href="#_5-2-2-案例" aria-label="Permalink to &quot;5.2.2 案例&quot;">​</a></h4><p><code>alter table tb_emp drop primary key</code></p><h2 id="_6-修改索引" tabindex="-1">6. 修改索引 <a class="header-anchor" href="#_6-修改索引" aria-label="Permalink to &quot;6. 修改索引&quot;">​</a></h2><p>先删除，再添加新的索引即可</p><h2 id="_7-查询索" tabindex="-1">7. 查询索 <a class="header-anchor" href="#_7-查询索" aria-label="Permalink to &quot;7. 查询索&quot;">​</a></h2><p>查询表有哪些索引又三种方式</p><ul><li><ol><li>方式1</li></ol></li></ul><p><code>SHOW INDEX FROM table_name</code></p><ul><li><ol start="2"><li>方式2</li></ol></li></ul><p><code>SHOW INDEXES FROM table_name</code></p><ul><li><ol start="3"><li>方式3</li></ol></li></ul><p><code>SHOW KEYS FROM table_name</code></p><h2 id="_8-创建索引规范" tabindex="-1">8. 创建索引规范 <a class="header-anchor" href="#_8-创建索引规范" aria-label="Permalink to &quot;8. 创建索引规范&quot;">​</a></h2><ul><li><ol><li>较频繁的作为<strong>查询条件字段</strong>应该创建索</li></ol></li></ul><p>适合在<code>empno</code>上创建索引</p><p><code>select * from emp where empno = 1</code></p><ul><li><ol start="2"><li>唯一性太差的字段不适和单独创建索引，即使频繁作为查询条件</li></ol></li></ul><p><code>sex</code>字段值只有<code>男</code>和<code>女</code>两种结果，唯一性太差，不适合做索引</p><p><code>select * from emp where sex = &#39;男&#39;</code></p><ul><li><ol start="3"><li>更新非常频繁的字段不适合创建索引</li></ol></li></ul><p>登录次数字段<code>logincount</code>会经常修改，不适合做索引。因为字段值经常修改，<strong>维护索引的代价是比较高的</strong></p><p><code>select * from emp where logincount =1</code></p><ul><li><ol start="4"><li>不会出现在<code>where</code>字句中的字段不该创建索引</li></ol></li></ul>`,91),r=[s];function t(c,d,i,p,h,u){return a(),o("div",null,r)}const b=e(n,[["render",t]]);export{_ as __pageData,b as default};
