import{_ as a,o as e,c as t,V as o}from"./chunks/framework.364d6ed5.js";const m=JSON.parse('{"title":"js为什么是单线程","description":"","frontmatter":{"title":"js为什么是单线程","date":"2022-01-14T15:49:39.000Z","permalink":"/pages/e7e3ed/","categories":["知识碎片"],"tags":[null]},"headers":[],"relativePath":"知识碎片/js为什么是单线程.md","filePath":"知识碎片/js为什么是单线程.md","lastUpdated":1685623283000}'),s={name:"知识碎片/js为什么是单线程.md"},r=o('<h2 id="什么是进程" tabindex="-1">什么是进程 <a class="header-anchor" href="#什么是进程" aria-label="Permalink to &quot;什么是进程&quot;">​</a></h2><p>进程是 <code>CPU 分配资源</code>的最小单位（是拥有资源和独立运行的最小单位）</p><h2 id="什么是线程" tabindex="-1">什么是线程 <a class="header-anchor" href="#什么是线程" aria-label="Permalink to &quot;什么是线程&quot;">​</a></h2><p>线程是 <code>CPU 调度</code>的最小单位。线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。</p><h2 id="浏览器是多进程的" tabindex="-1">浏览器是多进程的 <a class="header-anchor" href="#浏览器是多进程的" aria-label="Permalink to &quot;浏览器是多进程的&quot;">​</a></h2><p>在浏览器中，没打开一个 tab 页面，其实就是新打开了一个进程。在这个进程中还有<code>UI渲染线程</code>，<code>js引擎线程</code>，<code>http请求线程</code>等，所以浏览器是一个多进程的。</p><h2 id="js-是单线程" tabindex="-1">js 是单线程 <a class="header-anchor" href="#js-是单线程" aria-label="Permalink to &quot;js 是单线程&quot;">​</a></h2><p>为什么 js 要设计成单线程的呢？这主要和 js 的<strong>用途</strong>有关。js 作为浏览器的脚本语言，主要是实现了用户和浏览器的交互，以及 DOM 操作，这决定了它只能是单线程，否则就会带来很复杂的同步问题。</p><p>举个例子，如果 js 被设计成了多线程，如果一个线程要修改一个 dom 元素，另外一个线程要删除这个 dom 元素，此时浏览器就会一脸茫然，不知所措。所以为了避免复杂性，从一诞生，javascript 就是单线程，这已经成为了这门语言的核心特征，将来也不会改变。</p><p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以这个新标准也没有改变 JavaScript 单线程的本质。</p>',10),c=[r];function d(i,n,_,l,p,h){return e(),t("div",null,c)}const u=a(s,[["render",d]]);export{m as __pageData,u as default};
