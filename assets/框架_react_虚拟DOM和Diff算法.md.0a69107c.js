import{_ as s,o as a,c as l,V as n}from"./chunks/framework.364d6ed5.js";const _=JSON.parse('{"title":"虚拟DOM和Diff算法","description":"","frontmatter":{"title":"虚拟DOM和Diff算法","date":"2022-01-02T19:39:36.000Z","permalink":"/pages/b92638/","categories":["框架","react"],"tags":[null]},"headers":[],"relativePath":"框架/react/虚拟DOM和Diff算法.md","filePath":"框架/react/虚拟DOM和Diff算法.md","lastUpdated":1685623283000}'),o={name:"框架/react/虚拟DOM和Diff算法.md"},e=n(`<ul><li><ol><li>React 更新视图的思想是：只要<code>state</code>变化就重新渲染视图</li></ol></li><li><ol start="2"><li>组件中只有一个<code>DOM</code>元素需要更新时，也得把整个组件的内容重新渲染到页面中吗？ <strong>不是</strong></li></ol></li><li><ol start="3"><li>理想状态 ： <strong>部分更新</strong>，只更新变化的地方。</li></ol></li><li><ol start="4"><li>React 是如何做到部分更新的？ <strong>虚拟 DOM 配合 Diff 算法</strong></li></ol></li></ul><h2 id="_1-虚拟-dom-对象" tabindex="-1">1. 虚拟 DOM 对象 <a class="header-anchor" href="#_1-虚拟-dom-对象" aria-label="Permalink to &quot;1. 虚拟 DOM 对象&quot;">​</a></h2><p>虚拟 DOM 本质上就是一个<code>JS对象</code>，用来描述你希望在屏幕上看到的内容（UI）</p><p>下面就是一个简化的虚拟 DOM 对象。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> element </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">h1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">props</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">className</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">greeting</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">children</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello JSX</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_2-渲染的过程" tabindex="-1">2. 渲染的过程 <a class="header-anchor" href="#_2-渲染的过程" aria-label="Permalink to &quot;2. 渲染的过程&quot;">​</a></h2><ul><li><ol><li>初次渲染时，<code>React</code>会根据初始<code>state(Model)</code>，创建一个<strong>虚拟 DOM 对象（树）</strong></li></ol></li><li><ol start="2"><li>根据虚拟 <code>DOM</code>生成真正的<code>DOM</code>，渲染到页面中。</li></ol></li><li><ol start="3"><li>当数据变化后<code>setState()</code>，重新根据新的数据，创建新的虚拟 DOM 对象（树）</li></ol></li><li><ol start="4"><li>与上一次得到的虚拟 DOM 对象，使用<strong>Diff 算法</strong>对比（找不同），得到需要更新的内容。</li></ol></li><li><ol start="5"><li>最终，<code>React</code>只将<strong>变化的内容</strong>更新到 DOM 中，重新渲染到页面</li></ol></li></ul>`,7),t=[e];function p(r,c,i,D,d,y){return a(),l("div",null,t)}const u=s(o,[["render",p]]);export{_ as __pageData,u as default};
