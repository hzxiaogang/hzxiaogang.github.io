import{_ as e,o,c as l,V as d}from"./chunks/framework.364d6ed5.js";const u=JSON.parse('{"title":"SpringMVC执行流程","description":"","frontmatter":{"title":"SpringMVC执行流程","date":"2022-10-19T21:29:44.000Z","permalink":"/pages/4993e2/","categories":["java","ssm","springmvc"],"tags":[null]},"headers":[],"relativePath":"java/ssm/springmvc/SpringMVC执行流程.md","filePath":"java/ssm/springmvc/SpringMVC执行流程.md","lastUpdated":1685806707000}'),a={name:"java/ssm/springmvc/SpringMVC执行流程.md"},i=d('<h1 id="springmvc执行流程" tabindex="-1">SpringMVC执行流程 <a class="header-anchor" href="#springmvc执行流程" aria-label="Permalink to &quot;SpringMVC执行流程&quot;">​</a></h1><h2 id="_1-springmvc-常用组件" tabindex="-1">1. SpringMVC 常用组件 <a class="header-anchor" href="#_1-springmvc-常用组件" aria-label="Permalink to &quot;1. SpringMVC 常用组件&quot;">​</a></h2><h3 id="_1-1-dispatcherservlet" tabindex="-1">1.1 DispatcherServlet <a class="header-anchor" href="#_1-1-dispatcherservlet" aria-label="Permalink to &quot;1.1 DispatcherServlet&quot;">​</a></h3><p>前端控制器，不需要工程师开发，由框架提供。</p><p>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p><h3 id="_1-2-handlermapping" tabindex="-1">1.2 HandlerMapping <a class="header-anchor" href="#_1-2-handlermapping" aria-label="Permalink to &quot;1.2 HandlerMapping&quot;">​</a></h3><p>处理器映射器，不需要工程师开发，由框架提供。</p><p>作用：根据请求的 <code>url</code>、<code>method</code> 等信息查找<code>Handler</code>，即控制器方法</p><h3 id="_1-3handler" tabindex="-1">1.3Handler <a class="header-anchor" href="#_1-3handler" aria-label="Permalink to &quot;1.3Handler&quot;">​</a></h3><p>处理器，需要工程师开发</p><p>作用：在<code>DispatcherServlet</code> 的控制下 <code>Handler</code> 对具体的用户请求进行处理</p><h3 id="_1-4-handleradapter" tabindex="-1">1.4 HandlerAdapter <a class="header-anchor" href="#_1-4-handleradapter" aria-label="Permalink to &quot;1.4 HandlerAdapter&quot;">​</a></h3><p>处理器适配器，不需要工程师开发，由框架提供</p><p>作用：通过<code>HandlerAdapter</code> 对处理器（控制器方法）进行执行</p><h3 id="_1-5-viewresolver" tabindex="-1">1.5 ViewResolver <a class="header-anchor" href="#_1-5-viewresolver" aria-label="Permalink to &quot;1.5 ViewResolver&quot;">​</a></h3><p>视图解析器，不需要工程师开发，由框架提供</p><p>作用：进行视图解析，得到相应的视图，例如：<code>ThymeleafView</code>、<code>InternalResourceView</code>、 <code>RedirectView</code></p><h3 id="_1-6-view-视图" tabindex="-1">1.6 View：视图 <a class="header-anchor" href="#_1-6-view-视图" aria-label="Permalink to &quot;1.6 View：视图&quot;">​</a></h3><p>作用：将模型数据通过页面展示给用户</p><h2 id="_2-springmvc-执行流程" tabindex="-1">2. SpringMVC 执行流程 <a class="header-anchor" href="#_2-springmvc-执行流程" aria-label="Permalink to &quot;2. SpringMVC 执行流程&quot;">​</a></h2><ul><li><ol><li>用户向服务器发送请求，请求被 <code>SpringMVC</code> 前端控制器 <code>DispatcherServlet</code> 捕获。</li></ol></li><li><ol start="2"><li><code>DispatcherServlet</code> 对请求 <code>URL</code> 进行解析，得到请求资源标识符（<code>URI</code>），判断请求 <code>URI</code>对应的映射： <ul><li>2.1 不存在 <ul><li>i. 再判断是否配置了 <code>mvc:default-servlet-handler</code></li><li>ii. 如果没配置，则控制台报映射查找不到，客户端展示 <code>404</code> 错误</li><li>iii. 如果有配置，则访问目标资源（一般为静态资源，如<code>JS</code>,<code>CSS</code>,<code>HTML</code>）,找不到客户端也会展示 <code>404</code> 错误</li></ul></li><li>2.2 存在则执行下面的流程</li></ul></li></ol></li><li><ol start="3"><li>根据该 <code>URI</code>，调用 <code>HandlerMapping</code> 获得该 <code>Handler</code> 配置的所有相关的对象（包括 <code>Handler</code> 对象以及 <code>Handler</code> 对象对应的拦截器），最后以 <code>HandlerExecutionChain</code> 执行链对象的形式返回。</li></ol></li><li><ol start="4"><li><code>DispatcherServlet</code> 根据获得的 <code>Handler</code>，选择一个合适的 <code>HandlerAdapter</code>。</li></ol></li><li><ol start="5"><li>如果成功获得 <code>HandlerAdapter</code>，此时将开始执行拦截器的 <code>preHandler</code>(…)方法【正向】</li></ol></li><li><ol start="6"><li>提取 <code>Request</code> 中的模型数据，填充 <code>Handler</code> 入参，开始执行 <code>Handler</code>（<code>Controller</code>)方法，处理请求。 在填充 <code>Handler</code> 的入参过程中，根据你的配置，<code>Spring</code> 将帮你做一些额外的工作：</li></ol><ul><li>i. <code>HttpMessageConveter</code>： 将请求消息（如 <code>Json</code>、<code>xml</code> 等数据）转换成一个对象，将对象转换为指定 的响应信息</li><li>ii. 数据转换：对请求消息进行数据转换。如<code>String</code>转换成 <code>Integer</code>、<code>Double</code>等</li><li>iii. 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li><li>iiii. 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中</li></ul></li><li><ol start="7"><li><code>Handler</code> 执行完成后，向 <code>DispatcherServlet</code> 返回一个 <code>ModelAndView</code>对象。</li></ol></li><li><ol start="8"><li>此时将开始执行拦截器的<code>postHandle</code>(...)方法【逆向】。</li></ol></li><li><ol start="9"><li>根据返回的 <code>ModelAndView</code>（此时会判断是否存在异常：如果存在异常，则执行 <code>HandlerExceptionResolver</code> 进行异常处理）选择一个适合的 <code>ViewResolver</code> 进行视图解析，根据 <code>Model</code> 和 <code>View</code>，来渲染视图。</li></ol></li><li><ol start="10"><li>渲染视图完毕执行拦截器的 <code>afterCompletion</code>(…)方法【逆向】。</li></ol></li><li><ol start="11"><li>将渲染结果返回给客户端。</li></ol></li></ul>',21),r=[i];function c(t,n,s,p,h,_){return o(),l("div",null,r)}const v=e(a,[["render",c]]);export{u as __pageData,v as default};
