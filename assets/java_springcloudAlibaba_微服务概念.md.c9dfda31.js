import{_ as a,o as p,c as i,V as t}from"./chunks/framework.364d6ed5.js";const l="/assets/image-1027172014044.245a392e.png",o="/assets/image-1027173909529.9059ecf6.png",r="/assets/image-1027182534219.9da48ed5.png",s="/assets/image-1028094613926.7013189c.png",e="/assets/image-1028095743602.22f16e09.png",n="/assets/1028103739904.98caa0f7.png",g="/assets/SOA架构.788d120c.jpg",c="/assets/image-1028110735067.3798b091.png",u="/assets/微服务架构.7812746c.jpg",k=JSON.parse('{"title":"第一章 微服务概念","description":"","frontmatter":{},"headers":[],"relativePath":"java/springcloudAlibaba/微服务概念.md","filePath":"java/springcloudAlibaba/微服务概念.md","lastUpdated":1706582708000}'),d={name:"java/springcloudAlibaba/微服务概念.md"},h=t('<h1 id="第一章-微服务概念" tabindex="-1">第一章 微服务概念 <a class="header-anchor" href="#第一章-微服务概念" aria-label="Permalink to &quot;第一章 微服务概念&quot;">​</a></h1><h2 id="_1-1-单体、分布式、集群" tabindex="-1">1.1 单体、分布式、集群 <a class="header-anchor" href="#_1-1-单体、分布式、集群" aria-label="Permalink to &quot;1.1 单体、分布式、集群&quot;">​</a></h2><p>我们学习微服务之前,需要先理解单体、集群、分布式这些概念，这样会帮助我们在学习后面课程会更加容易些.</p><p><strong>单体</strong></p><p>一个系统业务量很小的时候所有的代码都放在一个项目中就好了，然后这个项目部署在一台服务器上就好了。整个项目所有的服务都由这台服务器提供。这就是单机结构。</p><p><img src="'+l+'" alt="image-1027172014044"></p><p>单体应用开发简单,部署测试简单.但是存在一些问题,比如:单点问题,单机处理能力有限,当你的业务增长到一定程度的时候，单机的硬件资源将无法满足你的业务需求。</p><p><strong>分布式</strong></p><p>由于整个系统运行需要使用到Tomcat和MySQL，单台服务器处理的能力有限,2G的内存需要分配给Tomcat和MySQL使用，，随着业务越来越复杂，请求越来越多. 内存越来越不够用了，所以这时候我们就需要进行分布式的部署.</p><p><img src="'+o+'" alt="image-1027173909529"></p><p>我们进行一个评论的请求，这个请求是需要依赖<strong>分布</strong>在两台不同的服务器的组件[Tomat和MySQL],才能完成的. 所以叫做分布式的系统.</p><p><strong>集群</strong></p><p>在上面的图解中其实是存在问题的，比如Tomcat存在单点故障问题，一旦Tomcat所在的服务器宕机不可用了，我们就无法提供服务了,所以针对单点故障问题，我们会使用集群来解决.那什么是集群模式呢?</p><p>单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。</p><p>但问题是用户的请求究竟由哪个节点来处理呢？最好能够让此时此刻负载较小的节点来处理，这样使得每个节点的压力都比较平均。要实现这个功能，就需要在所有节点之前增加一个“调度者”的角色，用户的所有请求都先交给它，然后它根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理。这个“调度者”有个牛逼了名字——负载均衡服务器。</p><p><strong><img src="'+r+'" alt="image-1027182534219"></strong></p><p>我们在上面的图中仅展示了Tomcat的集群，如果MySQL压力比较大的情况下，我们也是可以对MySQL进行集群的.</p><h2 id="_1-2-系统架构演变" tabindex="-1">1.2 系统架构演变 <a class="header-anchor" href="#_1-2-系统架构演变" aria-label="Permalink to &quot;1.2 系统架构演变&quot;">​</a></h2><p>随着互联网的发展，网站应用的规模也不断的扩大，进而导致系统架构也在不断的变化。</p><p>从互联网早起到现在，系统架构大体经历了下面几个过程: 单体应用架构---&gt;垂直应用架构---&gt;分布式架构---&gt;SOA架构---&gt;微服务架构。</p><p>接下来我们就来了解一下每种系统架构是什么样子的， 以及各有什么优缺点。</p><h3 id="_1-2-1-单体应用架构" tabindex="-1">1.2.1 单体应用架构 <a class="header-anchor" href="#_1-2-1-单体应用架构" aria-label="Permalink to &quot;1.2.1 单体应用架构&quot;">​</a></h3><p>​ 互联网早期，一般的网站应用流量较小，只需一个应用，将所有功能代码都部署在一起就可以，这样可以减少开发、部署和维护的成本。</p><p>​ 比如说一个电商系统，里面会包含很多用户管理，商品管理，订单管理，物流管理等等很多模块，我们会把它们做成一个web项目，然后部署到一台tomcat服务器上。</p><p><strong><img src="'+s+'" alt="image-1028094613926"></strong></p><p><strong>优点：</strong></p><ul><li><p>项目架构简单，小型项目的话， 开发成本低</p></li><li><p>项目部署在一个节点上， 维护方便</p></li></ul><p><strong>缺点：</strong></p><ul><li><p>全部功能集成在一个工程中，对于大型项目来讲不易开发和维护</p></li><li><p>项目模块之间紧密耦合，单点容错率低</p></li><li><p>无法针对不同模块进行针对性优化和水平扩展</p></li></ul><h3 id="_1-2-2-垂直应用架构" tabindex="-1">1.2.2 垂直应用架构 <a class="header-anchor" href="#_1-2-2-垂直应用架构" aria-label="Permalink to &quot;1.2.2 垂直应用架构&quot;">​</a></h3><p>​ 随着访问量的逐渐增大，单一应用只能依靠增加节点来应对，但是这时候会发现并不是所有的模块都会有比较大的访问量.</p><p>​ 还是以上面的电商为例子， 用户访问量的增加可能影响的只是用户和订单模块， 但是对消息模块的影响就比较小. 那么此时我们希望只多增加几个订单模块， 而不增加消息模块. 此时单体应用就做不到了， 垂直应用就应运而生了.</p><p>​ 所谓的垂直应用架构，就是将原来的一个应用拆成互不相干的几个应用，以提升效率。比如我们可以将上面电商的单体应用拆分成:</p><ul><li><p>电商系统(用户管理 商品管理 订单管理)</p></li><li><p>后台系统(用户管理 订单管理 客户管理)</p></li><li><p>CMS系统(广告管理 营销管理)</p></li></ul><p>这样拆分完毕之后，一旦用户访问量变大，只需要增加电商系统的节点就可以了，而无需增加后台</p><p>和CMS的节点。</p><p><strong><img src="'+e+'" alt="image-1028095743602"></strong></p><p><strong>优点：</strong></p><ul><li><p>系统拆分实现了流量分担，解决了并发问题，而且可以针对不同模块进行优化和水平扩展</p></li><li><p>一个系统的问题不会影响到其他系统，提高容错率</p></li></ul><p><strong>缺点：</strong></p><ul><li><p>系统之间相互独立， 无法进行相互调用</p></li><li><p>系统之间相互独立， 会有重复的开发任务</p></li></ul><h3 id="_1-2-3-分布式架构" tabindex="-1">1.2.3 分布式架构 <a class="header-anchor" href="#_1-2-3-分布式架构" aria-label="Permalink to &quot;1.2.3 分布式架构&quot;">​</a></h3><p>​ 当垂直应用越来越多，重复的业务代码就会越来越多。这时候，我们就思考可不可以将重复的代码抽取出来，做成统一的业务层作为独立的服务，然后由前端控制层调用不同的业务层服务呢？</p><p>​ 这就产生了新的分布式系统架构。它将把工程拆分成表现层和服务层两个部分，服务层中包含业务逻辑。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。</p><p><img src="'+n+'" alt="image-1028103739904"></p><p><strong>优点</strong>：</p><ul><li>抽取公共的功能为服务层，提高代码复用性</li></ul><p><strong>缺点</strong>：</p><ul><li>系统间耦合度变高，调用关系错综复杂，难以维护</li></ul><h3 id="_1-2-4-soa架构" tabindex="-1">1.2.4 SOA架构 <a class="header-anchor" href="#_1-2-4-soa架构" aria-label="Permalink to &quot;1.2.4 SOA架构&quot;">​</a></h3><p>​ 在分布式架构下，当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理。此时，用于资源调度和治理中心(SOA Service Oriented Architecture，面向服务的架构)是关键。</p><p><img src="'+g+'" alt="****"></p><p><strong>优点</strong>:</p><ul><li>使用注册中心解决了服务间调用关系的自动调节</li></ul><p><strong>缺点</strong>:</p><ul><li><p>服务间会有依赖关系，一旦某个环节出错会影响较大( 服务雪崩 )</p></li><li><p>服务关系复杂，运维、测试部署困难</p></li></ul><h3 id="_1-2-5-微服务架构" tabindex="-1">1.2.5 微服务架构 <a class="header-anchor" href="#_1-2-5-微服务架构" aria-label="Permalink to &quot;1.2.5 微服务架构&quot;">​</a></h3><p>微服务架构在某种程度上是面向服务的架构SOA继续发展的下一步，它更加强调服务的&quot;彻底拆分&quot;。</p><p><strong><img src="'+c+'" alt="image-1028110735067"></strong></p><p><strong>优点</strong>：</p><ul><li><p>服务原子化拆分，独立打包、部署和升级，保证每个微服务清晰的任务划分，利于扩展</p></li><li><p>微服务之间采用RESTful等轻量级Http协议相互调用</p></li></ul><p><strong>缺点</strong>：</p><ul><li>分布式系统开发的技术成本高（容错、分布式事务等）</li></ul><h2 id="_1-3-微服务架构介绍" tabindex="-1">1.3 微服务架构介绍 <a class="header-anchor" href="#_1-3-微服务架构介绍" aria-label="Permalink to &quot;1.3 微服务架构介绍&quot;">​</a></h2><p>​ 微服务架构， 简单的说就是将单体应用进一步拆分，拆分成更小的服务，每个服务都是一个可以独立运行的项目。</p><p><strong>微服务架构的常见问题</strong></p><p>一旦采用微服务系统架构，就势必会遇到这样几个问题：</p><ul><li><p>这么多小服务，如何管理他们？</p></li><li><p>这么多小服务，他们之间如何通讯？</p></li><li><p>这么多小服务，客户端怎么访问他们？</p></li><li><p>这么多小服务，一旦出现问题了，应该如何自处理？</p></li><li><p>这么多小服务，一旦出现问题了，应该如何排错?</p></li></ul><p>对于上面的问题，是任何一个微服务设计者都不能绕过去的，因此大部分的微服务产品都针对每一</p><p>个问题提供了相应的组件来解决它们。</p><p><img src="'+u+'" alt="****"></p><h2 id="_1-4-springcloud介绍" tabindex="-1">1.4 SpringCloud介绍 <a class="header-anchor" href="#_1-4-springcloud介绍" aria-label="Permalink to &quot;1.4 SpringCloud介绍&quot;">​</a></h2><p>Spring Cloud是一系列框架的集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p><p>Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><h3 id="_1-4-1-springboot和springcloud有啥关系" tabindex="-1">1.4.1 SpringBoot和SpringCloud有啥关系? <a class="header-anchor" href="#_1-4-1-springboot和springcloud有啥关系" aria-label="Permalink to &quot;1.4.1 SpringBoot和SpringCloud有啥关系?&quot;">​</a></h3><ul><li><p>SpringBoot专注于快速方便的开发单个个体微服务。</p></li><li><p>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、事件总线、分布式事务、等等集成服务。</p></li></ul><p><strong>总结</strong>: SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理组件的集合。</p><h3 id="_1-4-2-springcloud版本名称" tabindex="-1">1.4.2 SpringCloud版本名称? <a class="header-anchor" href="#_1-4-2-springcloud版本名称" aria-label="Permalink to &quot;1.4.2 SpringCloud版本名称?&quot;">​</a></h3><p>因为Spring Cloud不同其他独立项目，它是拥有很多子项目的大项目。所以它是的版本是 版本名+版本号 （如Greenwich.SR6）。 版本名：是伦敦的地铁名 版本号：SR（Service Releases）是固定的 ,大概意思是稳定版本。后面会有一个递增的数字。 所以 Greenwich.SR6就是Greenwich的第6个Release版本。</p><h3 id="_1-4-3-为什么选择springcloud-alibaba" tabindex="-1">1.4.3 为什么选择SpringCloud Alibaba？ <a class="header-anchor" href="#_1-4-3-为什么选择springcloud-alibaba" aria-label="Permalink to &quot;1.4.3 为什么选择SpringCloud Alibaba？&quot;">​</a></h3><p>我们这里为什么选择SpringCloud Alibaba呢，主要因为SpringCloud Netflix的组件：服务注册与发现的 Eureka、服务限流降级的 Hystrix、网关 Zuul都已经停止更新了，当然继续使用是没问题的，只是出现问题，官方不维护，需要自行解决.</p>',81),_=[h];function m(S,b,q,f,C,x){return p(),i("div",null,_)}const A=a(d,[["render",m]]);export{k as __pageData,A as default};
